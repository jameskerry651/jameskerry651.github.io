[{"title":"AVOD阅读笔记","url":"/2023/06/03/AVOD%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","content":"Joint 3D Proposal Generation and Object Detection from View AggregationOverall impression在Multiview 3d Object Detection的文章基础上改进诞生的，利用了很多相似的处理手段，并有不少改进。同时也有不少创新点，引入特征金字塔网络来实现小目标的识别。在雷达点云特征提取的地方基本和MV3D差不多。特征融合要比MV3D简单，用了crop and resize的手段来保证特征融合的时候可以执行 element-wise mean operation操作。\n对于噪音的鲁棒性更好\n技术细节有不少亮点，不亚于ideas\nKey ideas利用3D RPN网络来获取Box,这类box recall比较高，准度低.\n提出一种先进的特征提取网络，利用了全卷积+ 级联的方式\n利用了3D anchor projections 查表的形式，使得运行速度比一般网络稍快\nTechnical details在特征提取器的网络，修改了全卷积网络，然后把卷积后的特征加到反卷积后的特征图上，最终的输出特征图是高分辨率\n回归3D box的时候不是8个点24维向量，而是回归4个点+2个平面的高度，额外回归了方向向量，改进MV3D的车辆方向估计问题，并证明回归方向向量效果比角度好\n","tags":["AI","papernotes"]},{"title":"Multi-View-3D-Object-Detection-Network-for-Autonomous-Driving","url":"/2023/06/03/Driving/","content":"Multi-View 3D Object Detection Network for Autonomous DrivingOverall impression如标题所示，论文是主要研究了自动驾驶当中的3D目标检测，基于多视角：激光雷达鸟瞰视角，激光雷达前向视角，图像视角。论文当中数据处理比较有意思，分别针对不同的视角采用了一种编码的形式表现数据。比如鸟瞰视角把点云离散化，大概分辨率0.1m，然后计算不同各自当中的参数：稠密，反射率的最值等等。比如高度特征计算格子中最高的点。\nKey ideas数据处理比较特别，用3D Point Cloud Representation表示，不知道如何翻译。前向雷达视角还被映射到圆柱体面上，论文有给出公式计算\n多视角，多分枝的网络，网络的融合采用了分级融合，既不是late fusion ,也不是 early fusion，论文作者称其为deep fusion，似乎比较新，但好像不是首创\nOriented 3D Box Regression， 对于3D框的回归使用了24维向量回归8个顶点的坐标，而不是x,y,z,w,h,l,回归参数多，似乎效果也好。\nTechnical details网络架构是基于16层VGG网络修改得到的，加入了一些上采样的层，最后又用了ROS pooling 层，这个ROI pooling可以保证最后输出的特征向量长度一样，方便融合。每个视觉相同架构\n点云处理的时候，删除了一些范围的点云，减少了数据计算量。融合特征有相加，级联，但是作者采用了Element-wise Mean（逐元素均值）的方法融合。\n实验的时候做了一些比较，发现3D BOX的回归，单一视角鸟瞰效果最好，其次视觉，但是随便融合两个都比一个好\n","tags":["AI","papernotes"]},{"title":"Hello World","url":"/2023/06/03/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"pinna基础","url":"/2023/06/03/pinna%E5%9F%BA%E7%A1%80/","content":"pinia基础教程pinia 主要功能是储存全局状态，类似与数据库，让vue各个组件可以共享全局数据。实现数据的跨组件访问。\n1.引入piniaimport {createPinia} from \"pinia\";const pinia = createPinia();const app = createApp(App);app.use(pinia);\n\n2.创建一个store比如需要保存用户登录信息，就在store文件夹下面创建一个user.ts文件\nimport {defineStore} from \"pinia\";export const useUserStore = defineStore(\"user\", {    state: () =&gt; {        return {            name:'',            major:'',            schoolId:'',            level:-1,        }    }})\n\nstate 字段表示存储的状态，用箭头函数返回一个class对象，里面包含各种键值对。\n3.给store赋值import {useUserStore} from \"../store/user\"; const store = useUserStore();               //存储用户信息Pi store.name = res.data.data.name; store.level = res.data.data.level; store.major = res.data.data.major; store.schoolId = res.data.data.school_id;\n\n4.其它组件访问store的数据&lt;template&gt;    &lt;div class=\"bg\"&gt;        &lt;Card id=\"card\"&gt;            姓名：{{ name }}&lt;br&gt;            专业：{{ major }}&lt;br&gt;            学号：{{ schoolId }}        &lt;/Card&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import {storeToRefs} from \"pinia\";import {useUserStore} from \"../../store/user\";const store = useUserStore();const {name, major, schoolId, level} = storeToRefs(store);//响应式更新 和ref一样&lt;/script&gt;\n\n\n\n5.总结最核心的在于创建仓库，设定仓库的state，然后主要就是\nconst store = useUserStore(); \n\n，这一行代码用于访问仓库，给仓库修改数值或者访问值。\n"},{"title":"pip和conda换源","url":"/2023/06/03/pip%E5%92%8Cconda%E6%8D%A2%E6%BA%90/","content":"pip换源pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/\n\n注：尽量使用中科大的源，而不是清华的，中科大的速度大约是清华的10倍左右\nconda换源在.condarc隐藏文件中覆盖写入：\nchannels:  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/  - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/  - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ssl_verify: true\n"},{"title":"中值定理","url":"/2023/06/03/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E5%90%AB%E6%B3%B0%E5%8B%92)/","content":"中值定理介值定理：在上连续，其中是最小值，是最大值。当, 存在，使得.\n零点定理：当, 存在,使得 , 至少有一个根。\n以下三个定理前提条件：在上连续， 在可导。\n罗尔定理：若, 存在使得。\n拉格朗日中值定理：存在使得。\n变体： .  可以推导出配亚诺余项的另一种形式。\n柯西中值定理：存在, 使得。\n积分中值定理： 若在上连续,  则存在一点使得。\n泰勒定理：\n常见辅助函数用于选择题一般辅助函数是利用求导公式的逆用构造辅助函数\n\n见到 ,构造。\n见到, 构造。\n见到, 构造\n见到,构造\n见到,构造\n见到,构造\n\n\n\n做题tip：辅助函数对于构造原函数后用来判断单调区间非常有用，罗尔定理在一个函数的区间当中可以分段使用。\n零点问题和微分不等式罗尔定理推论：若至多有k个根，则至多有个根。  多项式重根是导函数的根，导函数的根重数减一.\n证明根存在性：\n\n​\t在上连续，当, 存在,使得 , 至少有一个根。\n​\t实系数奇次方程至少一个根\n\n证明根的唯一性：若在内单调，则在区间范围内至多一个根。\n函数单调性不等式：\n若，则有.\n若，则有.\n\n函数凹凸不等式：若有,则有. （可以简单通过二次函数推导结论）\n泰勒展开式当在可导时，在点邻域内恒有 \n\n其中是误差项，, 是与之间的某个值,要减少误差可以通过增加或则减少的距离。\n最常用的是当, 是常用的麦克劳林公式，其余项写作或者. 做题有时候会遇见！\n泰勒公式的余项有两类：一类是定性的皮亚诺余项，另一类是定量的拉格朗日余项。这两类余项本质相同，但是作用不同。一般来说，当不需要定量讨论余项时，可用皮亚诺余项（如求未定式极限及估计无穷小阶数等问题）；当需要定量讨论余项时，要用拉格朗日余项（如利用泰勒公式近似计算函数值）\n","tags":["math","微积分"]},{"title":"行列式介绍","url":"/2023/06/03/%E8%A1%8C%E5%88%97%E5%BC%8F/","content":"行列式行列式几何性质：二阶表示平行四边形面积，三阶表示以这三个向量为邻边的平行六面体的体积。\n行列式性质：\n行列互换，其值不变 \n某行元素全为0，行列式值为0.\n某行或某列有公因子， 则可以提到行列式外面\n某行或某列均是两个元素之和，可以拆成两个行列式之和\n两行或两列互换，行列式值反号。\n行列式两行或两列成比例，行列式值为0\n某行或某列的倍加到另一行或另一列，行列式值不变\n\n逆序数：一个级排列中， 若，这两个数构成一个逆序，逆序的总数称为逆序数，, 如.\n奇排列和偶排列：排列的逆序数为奇数则称为奇排列，为偶数称为偶排列。\nn阶行列式计算 \n简单理解为从每行选取一个值，一共有种排列方式，行号和列号不能重复。 然后项根据上式规则取正负相加。 奇排列负号，偶排列正号。\n代数余子式余子式： 在阶行列式，去掉元素所在的行和列元素，由剩下的元素按照原来的位置和顺序组成的阶行列式称为元素的余子式，记作.\n代数余子式：  \n代数余子式性质\n行列式的值等于某行（列）元素分别乘以对应的代数余子式再相加\n行列式某行（列）分别乘以另一行（列）元素的代数余子式在求和，结果为0.\n\n几个重要行列式主对角线行列式\n副对角线行列式同上不过对角线方向相反，计算结果为副对角线元素相乘再乘以一个系数，\n拉普拉斯展开式设为阶方矩阵，B为阶方矩阵\n\n\n范德蒙行列式\n二级结论：\n若都是同阶矩阵，则\n若是非奇异阵， 则\n柯西-毕内公式矩阵相乘\n\n若, \n若, \n若, \n\n注： 取阶子式根据定义组合\n","tags":["math","线性代数"]}]